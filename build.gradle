plugins {
    id 'org.springframework.boot' version "${springBootVersion}"
    id 'io.spring.dependency-management' version "${dependencyManagementVersion}"
    id 'org.sonarqube' version "${sonarQubeVersion}"
    id 'org.flywaydb.flyway' version "${flywayPluginVersion}"
    id 'com.diffplug.spotless' version "${spotlessVersion}"
    id 'jacoco'
    id 'java'
}


description = description
group = group
version = version

sourceCompatibility = '17'


repositories {
    mavenCentral()
}

apply from: 'dependencies.gradle'

def dbUrl = System.getenv('DATABASE_URL')
def dbUser = System.getenv('PGUSER')
def dbPass = System.getenv('PGPASSWORD')

import groovy.io.FileType

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

static String getCurrentDateTimeFormatted() {
    LocalDateTime now = LocalDateTime.now()
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss")
    return now.format(formatter)
}

import org.flywaydb.gradle.task.FlywayMigrateTask

tasks.register('generateSqlWithTimestampAndTable', FlywayMigrateTask) {
    group = 'database'
    description = 'Generate SQL file using Flyway with timestamp and table name'

    // Defina a configuração do Flyway aqui (ou reutilize a configuração global do Flyway)
    url = "${dbUrl}"
    user = "${dbUser}"
    password = "${dbPass}"
    locations = ['filesystem:src/main/resources/db/migration']

    doLast {
        if (tableName.trim()) {
            // Ative a geração do arquivo SQL com data e hora e nome da tabela
            String timestamp = getCurrentDateTimeFormatted()
            // Create the SQL file with the table name and timestamp
            File outputFile = file("src/main/resources/db/migration/V${timestamp}__${tableName}.sql")

            // Adicione um sufixo de incremento se o arquivo já existir
            int suffix = 1;
            while (outputFile.exists()) {
                outputFile = file("src/main/resources/db/migration/V${timestamp}__${tableName}_${suffix}.sql")
                suffix++;
            }
            outputFile.createNewFile()

        } else {
            println "Please provide a table name using -PtableName=your_table_name"
        }
    }
}

flyway {
    url = "${dbUrl}"
    user = "${dbUser}"
    password = "${dbPass}"
    locations = ['filesystem:src/main/resources/db/migration']
}

jacoco {
    toolVersion = "0.8.9"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.enabled true
		xml.outputLocation.set(layout.buildDirectory.file("$buildDir/jacoco/jacoco.xml"))
        csv.enabled false
        html.enabled true
        html.outputLocation.set(layout.buildDirectory.dir("$buildDir/reports/jacoco"))
    }
}

jacocoTestCoverageVerification {
   
}

sonarqube {
    properties {
        property "sonar.projectKey", "mayconaraujosantos_hrms-erp"
        property "sonar.organization", "mayconaraujosantos"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.coverage.jacoco.xmlReportPaths", "${rootProject.buildDir}/reports/jacoco/test/jacocoTestReport.xml"
    }
}

spotless {
    java {
        target fileTree('.') {
            include '**/*.java'
            exclude '**/build/**', '**/build-*/**'
        }
        googleJavaFormat('1.17.0')
        toggleOffOn()
        palantirJavaFormat()
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}

test {
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
}

test.finalizedBy jacocoTestReport
jacocoTestCoverageVerification.dependsOn jacocoTestReport
check.dependsOn jacocoTestCoverageVerification

tasks.named('test') {
    useJUnitPlatform()
}

