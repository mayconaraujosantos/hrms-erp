plugins {
    id 'org.springframework.boot' version "${springBootVersion}"
    id 'io.spring.dependency-management' version "${dependencyManagementVersion}"
    id 'org.sonarqube' version "${sonarQubeVersion}"
    id 'org.flywaydb.flyway' version "${flywayVersion}"
    id 'com.diffplug.spotless' version "${spotlessVersion}"
    id 'jacoco'
    id 'java'
}

description = description
group = group
version = version

sourceCompatibility = '17'

repositories {
    mavenCentral()
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springbootframework.boot'
    
    repositories {
        mavenCentral()
    }
    
}
apply from: 'dependencies.gradle'


def dbUrl = System.getenv('DATABASE_URL')
def dbUser = System.getenv('PGUSER')
def dbPass = System.getenv('PGPASSWORD')


import org.flywaydb.gradle.task.FlywayMigrateTask

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

static String getCurrentDateTimeFormatted() {
    LocalDateTime now = LocalDateTime.now()
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss")
    return now.format(formatter)
}

tasks.register('generateSqlWithTimestampAndTable', FlywayMigrateTask) {
    group = 'database'
    description = 'Generate SQL file using Flyway with timestamp and table name'

    // Defina a configuração do Flyway aqui (ou reutilize a configuração global do Flyway)
    url = "${dbUrl}"
    user = "${dbUser}"
    password = "${dbPass}"
    locations = ['filesystem:src/main/resources/db/migration']

    doLast {
        if (tableName.trim()) {
            // Ative a geração do arquivo SQL com data e hora e nome da tabela
            String timestamp = getCurrentDateTimeFormatted()
            // Create the SQL file with the table name and timestamp
            File outputFile = file("src/main/resources/db/migration/V${timestamp}__${tableName}.sql")

            // Adicione um sufixo de incremento se o arquivo já existir
            int suffix = 1
            while (outputFile.exists()) {
                outputFile = file("src/main/resources/db/migration/V${timestamp}__${tableName}_${suffix}.sql")
                suffix++
            }
            outputFile.createNewFile()

        } else {
            println "Please provide a table name using -PtableName=your_table_name"
        }
    }
}


flyway {
    url = "${dbUrl}"
    user = "${dbUser}"
    password = "${dbPass}"
    locations = ['filesystem:src/main/resources/db/migration']
}

jacoco {
    toolVersion = "0.8.9"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.enabled true
        xml.outputLocation.set(layout.buildDirectory.file("jacoco/jacoco.xml"))
        csv.enabled false
        html.enabled true
        html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco"))
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.8
            }
        }
        rule {
            enabled = false
            element = 'CLASS'
            includes = ['org.gradle.*']

            limit {
                counter = 'LINE'
                value = 'TOTALCOUNT'
                minimum = 0.8
            }
            excludes = []
        }

        rule {
            enabled = true
            limit {
                counter = 'METHOD'
                minimum = 0.8
            }
            excludes = []
        }
    }
}

sonarqube {
    properties {
        property "sonar.projectKey", "mayconaraujosantos_mkdata-company"
        property "sonar.organization", "mayconaraujosantos"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.coverage.jacoco.xmlReportPaths", "${rootProject.buildDir}/reports/jacoco/test/jacocoTestReport.xml"
    }
}

spotless {
    java {
        target fileTree('.') {
            include '**/*.java'
            exclude '**/build/**', '**/build-*/**'
        }
        googleJavaFormat('1.17.0')
        toggleOffOn()
        palantirJavaFormat()
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}

test {
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
}

test.finalizedBy jacocoTestReport
jacocoTestCoverageVerification.dependsOn jacocoTestReport
check.dependsOn jacocoTestCoverageVerification

tasks.named('test') {
    useJUnitPlatform()
}

